"use client";

import { useState, useCallback, useEffect } from "react";
import FileService, { FileData } from "../services/FileService";

// Types
export type NotificationType = "success" | "error" | "info";

export interface Notification {
  message: string;
  type: NotificationType;
}

export interface ProcessingProgress {
  processed: number;
  total: number;
}

// Storage key for files
const STORED_FILES_KEY = "textExtractor_files";

/**
 * Custom hook for handling file operations
 */
export function useFileManagement() {
  const [files, setFiles] = useState<FileData[]>(() => {
    // Initialize files from localStorage if available
    if (typeof window !== "undefined") {
      const storedFiles = localStorage.getItem(STORED_FILES_KEY);
      return storedFiles ? JSON.parse(storedFiles) : [];
    }
    return [];
  });

  const [isProcessing, setIsProcessing] = useState(false);
  const [processingProgress, setProcessingProgress] =
    useState<ProcessingProgress>({
      processed: 0,
      total: 0,
    });
  const [notification, setNotification] = useState<Notification | null>(null);

  // Persist files to localStorage whenever they change
  useEffect(() => {
    if (typeof window !== "undefined") {
      localStorage.setItem(STORED_FILES_KEY, JSON.stringify(files));
    }
  }, [files]);

  /**
   * Show a notification message
   */
  const showNotification = useCallback(
    (message: string, type: NotificationType = "info") => {
      setNotification({ message, type });

      // Auto-hide notification after 3 seconds
      setTimeout(() => {
        setNotification(null);
      }, 3000);
    },
    []
  );

  /**
   * Process files and update state
   */
  const processFiles = useCallback(
    async (rawFiles: File[]) => {
      if (!rawFiles.length) return;

      setIsProcessing(true);
      setProcessingProgress({ processed: 0, total: rawFiles.length });

      try {
        const processedFiles = await FileService.processTextFiles(
          rawFiles,
          (processed, total) => {
            setProcessingProgress({ processed, total });
          }
        );

        setFiles((prevFiles) => {
          // Create a map of existing files for quick lookup
          const existingFiles = new Map(
            prevFiles.map((file) => [file.name, file])
          );

          // Merge new files with existing ones, overwriting duplicates
          processedFiles.forEach((file) => {
            existingFiles.set(file.name, file);
          });

          return Array.from(existingFiles.values());
        });

        showNotification(
          `Processed ${rawFiles.length} file(s) successfully`,
          "success"
        );
      } catch (error) {
        console.error("Error processing files:", error);
        showNotification("Error processing files", "error");
      } finally {
        setIsProcessing(false);
      }
    },
    [showNotification]
  );

  /**
   * Copy a specific file's content to clipboard
   */
  const copyFileContent = useCallback(
    async (text: string, fileName: string) => {
      try {
        await FileService.copyToClipboard(text);
        showNotification(`Copied ${fileName}`, "success");
      } catch (error) {
        showNotification("Failed to copy to clipboard", "error");
      }
    },
    [showNotification]
  );

  /**
   * Copy all files' content to clipboard
   */
  const copyAllFiles = useCallback(async () => {
    if (!files.length) return;

    try {
      const allText = files
        .map((file) => `--- ${file.name} ---\n${file.text}`)
        .join("\n\n");

      await FileService.copyToClipboard(allText);
      showNotification("Copied all files", "success");
    } catch (error) {
      showNotification("Failed to copy to clipboard", "error");
    }
  }, [files, showNotification]);

  /**
   * Clear notification
   */
  const clearNotification = useCallback(() => {
    setNotification(null);
  }, []);

  /**
   * Remove a file by name
   */
  const removeFile = useCallback(
    (fileName: string) => {
      setFiles((prev) => prev.filter((file) => file.name !== fileName));
      showNotification(`Removed ${fileName}`, "info");
    },
    [showNotification]
  );

  /**
   * Clear all files
   */
  const clearAllFiles = useCallback(() => {
    setFiles([]);
    showNotification("All files cleared", "info");
  }, [showNotification]);

  return {
    files,
    isProcessing,
    processingProgress,
    notification,
    processFiles,
    copyFileContent,
    copyAllFiles,
    clearNotification,
    removeFile,
    clearAllFiles,
  };
}

export default useFileManagement;
